[TOC] 
### 算法
#### 1. 打印字符串全排列  
递归后需要马上还原（因为所有的），因为递归是一颗深度优先的树（也就是栈），是先从叶子开始改变的
#### 2. 二叉搜索树转为双向链 
中序遍历二叉搜索树正好是递增的，只需要把结点左右指针连接中序中前后的结点。（二叉搜索树没有相同值的点）
#### 3. 递归求排列  
求排列时若用递归法，递归叶子回溯到父亲时需要还原改变（叶子最先改变，也就是说是从字符串数组最后两位开始的），不然就不是同一串字符串出发的（画出排列树推吧）
#### 3. 复制复杂链表 
每个结点复制一个接在该结点后面，a->a'->b->b'->c->c'，同时复制原结点所指向的任意结点，最后奇偶结点分离（跳着分离）
#### 4. 最小的k个数  
 partition函数（快排）最后得到的index就是他在序列中的位置，左边的就是前index个数。（期间可以用二分法逐渐缩小区间，由于是用一个固定位置的数作pivot所以最后得到的index是针对整个数组而言的）
#### 5. 集合和最大堆基于红黑树  
####  6. 最大子数组和 #### 
如果累加和为负则重新从新元素开始
####  7. 从1到n数里包含1的个数  
O(log10N) ， 十位上，每轮出现10次是指[10,19]这10个数	[解析](http://blog.csdn.net/yi_afly/article/details/52012593)  
####  8. 逆序对  
归并排序的同时进行计数
####  9. 数组排成最小的数  
可以用sprintf将数字写入字符串
####  10. 二叉树最低公共祖先  
（若是二叉搜索树）比一个结点大，比另一个结点小；（若有指向父节点的指针）寻找两个链表的公共结点；（什么都不是）用栈递归到叶子再逐个往上退栈。
####  11. 二叉树路径和等于某个数  
传递vector的引用（用vector作栈方便顺序输出），递归遍历，进入结点时压入该结点，退出时弹出（恢复成父节点进入的情景）
####  12. 不能继承的类  
虚拟继承virtual 父类，把父类构造函数设为私有，并且父类含有一个友元函数，友元函数的类型是由模板类给出的，所以虚拟继承的时候需要把子类的类型当成<typename>参数传入；（只能在堆上）私有构造与析构，用静态getInstance函数返回一个新的父类对象。
####  13. C++按类中声明的元素顺序初始化成员  
####  14.  求方程正整数解个数 
[求方程正整数解个数](https://www.nowcoder.com/questionTerminal/4a625528d7be46da8aaa4af999c40346)
#### 15. 多路平衡归并排序  
外排序，m个归并项（子表个数）k路归并的归并趟数s=logk(m)，[败者树](http://www.360doc.com/content/15/0719/22/22633806_486084820.shtml)
#### 16. n阶乘末尾0的个数  
（n除以5，即求5的质因数个数）
存在0必然是5*2的结果，所以必然含有5!(5*4*3*2*1)，所以只要求多少个5的倍数即可
#### 17. mongodb为什么没有自增id  
因为并发情况下同时插入,分布式存储的情况下无法协调分配连续数字（协调需要消耗网络资源），并且内部也不是按id顺序存的，因为文档长度可变，不知道什么时候文档变长要放到后面去
#### 18. 数n的约数个数  
（约数：能把别人整除的叫约数）自然数的约数的个数是有限的，质数的约数是1和本身；合数一定有3个以上的约数。由于约数个数定理知道：约数的个数等于:所有质因数的指数加上1后的乘积;
若一个数分解质因数后为(a^m)*(b^n),其中a,b均为质因数;m,n均为相应质因数的指数.
则约数个数为(m+1)(n+1).(因为a^0,a^1 ... a^m，都是它的约数共m+1个) 
> 例如:
(1)12=2^2*3,质因数有2和3,其指数分别为2和1,那么12的约数有(2+1) *(1+1)=6(个);
(2)60=22 * 3 * 5,质因数2, 3, 5的指数分别为2, 1, 1,那么60的约数有(2+1)*(1+1) * (1+1)=12(个)
#### 19. 一个数所有约数之和  
一个数所有约数之和 等于先把每个质因数从0次幂一直加到其最高次幂,再把每个相应质因数幂的和相乘.
若一个数分解为(a^m)*(b^n),则这个数所有约数的和为:
(a^0+a^1+a^2+a^3+…+a^m)(b^0+b^1+b^2+b^3+…+b^n).
>例如:
(1)12=22*3,则12所有约数的和为：(2^0+2^1+2^2)*(3^0+3^1)=7*4=28;
(2)60=22*3*5=(2^0+2^1+2^2)*(3^0+3^1)*(5^0+5^1)=7*4*6=168.
#### 20. Trie 树 #### 
#### 21. 需要同时移动多少步A和B才同时指向一个节点 ####
长度为100的循环链表，指针A和指针B都指向了链表中的同一个节点，A以步长为1向前移动，B以步长为3向前移动，一共需要同时移动多少步A和B才能再次指向同一个节点？
假定经过n步A、B再次相遇。则A经过的结点为n，B经过的结点为3n；此刻B必然比A多经过了整数倍的链表长度（圈的长度），假定经过了i倍的链表长度，则有3n-n=100i，即2n=100i；满足该等式的最小整数位i=2，n=100。即A经过了100个结点，B经过了300个结点，二者再次相遇。
> 也可以认为跑圈100m，A速度1m/s B速度3m/s，B比A多跑一圈耗时100/（3-1）=50s
### 基础 
#### 1. accept在三次握手之后 
#### 2. 静态链接库（在编译时）和动态链接库（在运行时）的区别 ####
#### 3. 模拟加减法  
####4. 索引
####5. epoll
####6. 设计模式
####7. Socket过程：
####8. 流水线
####9. *p++与*++p
 int* p = (int*)(&a+1) , char ** a = {"hello","wordld","hi","bye"}
p是个数组，所以 sizeof(p) 返回数组的占用大小，64 位情况下
```
【char **p[4] 】 表示 【char** 数组】 返回 4 * 8 = 32

【char *(*p)[4] 】 表示 【指向 char* 数组的指针】 返回 8

【char （**p） [4]?】 表示 【指向?char 数组的指针的指针】?返回 8
```
#### 10. 字符串复制函数：springtf, memcpy, strcpy, strstr
（strstr是查找子串函数）
####11. 多线程的那点儿事（之读写锁）####
copyOnWrite，分区锁的问题
