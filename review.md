

1. 单例设计模式
2. 一个数组复制到另一个数组：从后往前
3. 双栈模拟队列时，当弹出栈有内容的时候可以直接弹出，如果弹出栈为空，需要把压入栈所有的内容先压入弹出栈。
    > 压入栈直接压入就可以
4. 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法？[解答](https://segmentfault.com/q/1010000003797424/a-1020000003797605)
5. 负数的右移运算，是用1来补齐左边空位的
     
> Fibonacci数列，f(n) = f(n-1) + ... + f(1) + 1 ， 即跳1级然后剩下n-1级怎么跳，跳2级剩下n-2级再计算，跳n-1级剩下1级，n级跳完（算一种）
>> 而f(n) = f(n-1) + ... + f(1) + 1 往下列然后乘2的幂可得 f(n) = 2^(n-1) , f(n) = 2 * f(n-1)



3. [不带头结点尾插入，第一个节点与其他节点分开](http://blog.csdn.net/xlf13872135090/article/details/8857632)
  ```
       void CreatList(Node  **head){      
       ...
       }
  ```
>    带头结点的初始化在堆开辟了一段内存，需要修改head指针变量指向的地址(即head的值)，所以要修改head的值，必须传保存head变量的地址(即二维指针)。而直接调用CreatList(head);相当于传head变量的值，函数修改的是head的副本，无法真正改变head的值。 
>    注：这里可以将head指针看成一个变量(不管它保存的是地址)，就比较好理解了。
>    其实本质上还是传值，传址的问题，只不过指针本身保存的地址，让这个过程变得有点纠结。在函数调用需要修改指针变量的指向(value)时，应该传递指针变量的地址(address)
>    另外，**对于函数的形参是指针时，只要该参数不在左边（即都是右值操作），二维指针(形参)就可以简化为一维指针** 


