1. 单例设计模式
2. 一个数组复制到另一个数组：从后往前
3. 双栈模拟队列时，当弹出栈有内容的时候可以直接弹出，如果弹出栈为空，需要把压入栈所有的内容先压入弹出栈。
    > 压入栈直接压入就可以
4. 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法？[解答](https://segmentfault.com/q/1010000003797424/a-1020000003797605)
5. 负数的右移运算，是用1来补齐左边空位的。所以不能通过 << 来检查二进制中1的个数，但是可以换一种方式，左移0x0001去 & 这个负数
     
> Fibonacci数列，f(n) = f(n-1) + ... + f(1) + 1 ， 即跳1级然后剩下n-1级怎么跳，跳2级剩下n-2级再计算，跳n-1级剩下1级，n级跳完（算一种）
>> 而f(n) = f(n-1) + ... + f(1) + 1 往下列然后乘2的幂可得 f(n) = 2^(n-1) , f(n) = 2 * f(n-1)
6. n = (n - 1) & n 可以将最末尾的1变为0，如果一个数是2的幂次，那么他的二进制有且仅有一位1
7. 打印1~n的所有数，可以看成字符串大数——的排列，递归改变每一位的排列（像树一样，叶结点先改变个位，上一层）
8. O(1)内删除链表给出的某个结点，顺序查找该结点的前一个结点需要O(n)的时间，如果直接用后面的结点覆盖被删除结点就不需要找前一个结点
> 需要注意的是链表为空、删除链表尾部的结点等情况，此时只能用顺序查找，平均下来时间仍在O(1)内
> 当点**被删除结不在链表内**时，只能顺序查找（注意头结点为空，要删除的指针为空等情况）
9. 倒数第k个(链表):
> 倒数第k个就是正数第n-k+1个，和末尾间隔k-1
>> 保持两个指针间隔k-1，当ahead指针走到末尾，behind指针和末尾间隔k-1，是第正着n-(k-1)个。倒数第k个结点
> 注意头指针为空，求倒数第0个（不存在），结点总数小于k还求倒数第k个的情况

3. [不带头结点尾插入，第一个节点与其他节点分开](http://blog.csdn.net/xlf13872135090/article/details/8857632)
  ```
       void CreatList(Node  **head){      
       ...
       }
  ```
>    带头结点的初始化在堆开辟了一段内存，需要修改head指针变量指向的地址(即head的值)，所以要修改head的值，必须传保存head变量的地址(即二维指针)。而直接调用CreatList(head);相当于传head变量的值，函数修改的是head的副本，无法真正改变head的值。 
>    注：这里可以将head指针看成一个变量(不管它保存的是地址)，就比较好理解了。
>    其实本质上还是传值，传址的问题，只不过指针本身保存的地址，让这个过程变得有点纠结。在函数调用需要修改指针变量的指向(value)时，应该传递指针变量的地址(address)
>    另外，**对于函数的形参是指针时，只要该参数不在左边（即都是右值操作），二维指针(形参)就可以简化为一维指针** 


