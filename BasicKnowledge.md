 
####1. accept在三次握手之后
####2. 静态链接库（在编译时）和动态链接库（在运行时）的区别
####3. 模拟加减法
####4. 索引
####5. epoll
####6. 设计模式
####7. Socket过程：
####8. 流水线
####9. *p++与*++p，int* p = (int*)(&a+1) , char ** a = {"hello","wordld","hi","bye"}
p是个数组，所以 sizeof(p) 返回数组的占用大小，64 位情况下
```
【char **p[4] 】 表示 【char** 数组】 返回 4 * 8 = 32

【char *(*p)[4] 】 表示 【指向 char* 数组的指针】 返回 8

【char （**p） [4]?】 表示 【指向?char 数组的指针的指针】?返回 8
```

####10. 字符串复制函数：springtf, memcpy, strcpy, strstr（strstr是查找子串函数）
####11. 多线程的那点儿事（之读写锁）:copyOnWrite，分区锁的问题

#### 12. grep命令 
统计文件或者文本中包含匹配字符串的行数 -c 选项：` grep -c "text" file_name `
输出包含匹配字符串的行数 -n 选项：` grep "text" -n file_name ` 或 ` cat file_name | grep "text" -n `
多个文件：` grep "text" -n file_1 file_2 `
#### find命令

#### 位运算
```
#define setbit(x,y)  x|=(1<<y)  
#define clrbit(x,y)  x&=~(1<<y)  
#define reversebit(x,y)  x^=(1<<y)  
#define getbit(x,y)   ((x) >> (y)&1)
```

#### TCP发送缓冲区最小可以设置为
 
阿里巴巴有相距1500km的机房A和B，现有100GB数据需要通过一条FTP连接在100s的时间内从A传输到B。已知FTP连接建立在TCP协议之上，而TCP协议通过ACK来确认每个数据包是否正确传送。网络信号传输速度2*108m/s，假设机房间带宽足够高，那么A节点的发送缓冲区可以设置为最小（A）
A、18M B、12M C、6M D、24M 

>解析： 
TCP协议原理：TCP每发送一个报文段，就启动一个定时器，如果在定时器超时之后还没有收到ACK确认，就重传该报文。
数据包由A的缓冲区发往B，B在收到数据包以后，回发一个ACK确认包给A，之后A将该数据包从缓冲区释放。因此，该数据包会一直缓存在A的缓冲区，直到一个ACK确认为止。题目要求在100s内发送100GB数据，网络的传输速率至少是1G/s，某个数据包n在A中缓存的时间就是数据包n从A到B，再加上该数据包的ACK从B到A的时间：2*1500km/(2*108m/s)=1.5*10-2s，该段时间A中缓存的数据量至少是1G/s*1.5*10-2s约为15M

>> 个人感觉这种方法不是十分准确，因为TCP连接有滑动窗口机制，可以在未收到ACK的时候继续发送数据，所以极端情况下A节点的发送缓冲区可以再减少一半，即在7.5M左右。不过题目里并没有说到滑动窗口机制，而是说通过ACK来确认每个数据报是否正确传送，所以应该不考虑这种极端情况。




#### sizeof运算符
int a[10]={...} ; int* p = a;
数组名a是一个常量指针，sizeof(a)返回数组总个数
sizeof(*p)返回第一个元素所占用的字节数

#### strlen 和 sizeof
strlen()计算字符数组的字符数，以"\0"为结束判断，不计算为'\0'的数组元素。
sizeof计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示。
##### sizeof(指针)经典问题：         
所有指针都是占4字节 (64位8字节)
```C++
double* (*a)[3][6];         
cout<<sizeof(a)<<endl; // 4 a为指针        
cout<<sizeof(*a)<<endl; // 72 *a为一个有3*6个指针元素的数组       
cout<<sizeof(**a)<<endl; // 24 **a为数组一维的6个指针       
cout<<sizeof(***a)<<endl; // 4 ***a为一维的第一个指针       
cout<<sizeof(****a)<<endl; // 8 ****a为一个double变量
```
##### 使用sizeof时string的注意：string s="hello";     
sizeof(s)等于string类的大小，sizeof(s.c_str())得到的是与字符串长度

##### union 与struct的空间计算    
总体上遵循两个原则：     
(1)整体空间是 占用空间最大的成员（的类型）所占字节数的整倍数    
(2)数据对齐原则----内存按结构成员的先后顺序排列，当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整倍数，如果不够则补齐，以此向后类推
注意：数组按照单个变量一个一个的摆放，而不是看成整体。如果成员中有自定义的类、结构体，也要注意数组问题。

##### 结构体的陷阱
这里有个陷阱，对于结构体中的结构体成员，不要认为它的对齐方式就是他的大小，看下面的例子： struct s1 {  char a[8]; }; 
```C++
struct s2 {  double d; };   
struct s3 { s1 s; char a; };   
struct s4 { s2 s; char a;  };  
cout<<sizeof(s1)<<endl; // 8 
cout<<sizeof(s2)<<endl; // 8 
cout<<sizeof(s3)<<endl; // 9 
cout<<sizeof(s4)<<endl; // 16;    
```
s1和s2大小虽然都是8，但是s1的对齐方式是1，s2是8（double），所以在s3和s4中才有这样的差异。

#### 指针常量与常量指针
##### 常量指针
常量指针限制了通过这个指针修改变量的值的可能
1）const int *p;
2）int const *p;
指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改，也就是说常量指针可以被赋值为变量的地址
> 特点是，const的位置在指针声明运算符*的左侧。只要const位于*的左侧，无论它在类型名的左边或右边，都声明了一个指向常量的指针，叫做常量指针。

##### 指针常量
指针常量的本质是一个常量，说明这个常量的值应该是一个指针
指针常量的值是指针，这个值因为是常量，所以不能被赋值。
 
> int *const b = &a; //const放在指针声明操作符的右侧
声明了一个常量b，它的值是变量a的地址（变量a的地址，不就是指向变量a的指针吗）。
因为指针常量是一个常量，在声明的时候一定要给它赋初始值。一旦赋值，以后这个常量再也不能指向别的地址。
虽然指针常量的值不能变，可是它指向的对象是可变的，因为我们并没有限制它指向的对象是常量。

##### 指向常量的指针常量
顾名思议，指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。
> const int * const b = &a;
左边有一个const，说明声明的是一个指向常量的指针
右边有一个const，说明声明的是一个指针常量
前后都锁死了，那么指向的对象不能变，指针常量本身也不能变。

#### 数组指针和指针数组
##### 数组指针（也称行指针）
- `	int (*p)[n];` 数组指针也称指向一维数组的指针，亦称行指针 
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度

- 如要将二维数组赋给一指针，应这样赋值：
```C++
	int a[3][4];  
	int (*p)[4]; //p只是一个变量，变量的值是指向含4个元素的一维数组。说明它的步长是4
	 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
	 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
```


##### 指针数组
- `	int *p[n]; `
[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素
> 这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址
>> 但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值

- 如要将二维数组赋给一指针数组:
```C++
	int *p[3];
	int a[3][4];
	p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针
	for(i=0;i<3;i++)
		p[i]=a[i];
```
这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。
##### a 与 &a
设 ` char a[5] = {'a'....'e'}; `
&a是整个数组的首地址，a是数组首元素的首地址，其值相同但意义不同
a的类型是char *
&a的类型是char (*)[5]，可以强制转换 (char (*)[5])a;
> 所以a+1是下一个元素，而&a+1是数组全部元素后的地址（即&a的步长是数组长度5）

##### 地址强制转换
设p的值为0x100000,指向一个结构体Test，结构体大小为20byte
- ` p + 0x1 的值为0x100000+sizof（Test）*0x1 ` = 0x100014

- (unsigned long)p + 0x1 = 0x100001
这里涉及到强制转换，将指针变量p 保存的值强制转换成无符号的长整型数
任何数值一旦被强制转换，其类型就改变了。所以这个表达式其实就是一个无符号的长整型数加上另一个整数

- (unsigned int*)p + 0x1 = 0x100004
p 被强制转换成一个指向无符号整型的指针，sizeof(指针)为4

```C++
   int *ptr1=(int *)(&a+1);//指向a数组后面的内存单元，&a+1表示向后移16个存储单元
   //ptr1将&a+1 的值强制转换成int*类型，赋值给int* 类型的变量ptr，ptr1 肯定指到数组a 的下一个int 类型数据了。ptr1[-1]被解析成*(ptr1-1)，即ptr1 往后退4 个byte。所以其值为0x4。

   int *ptr2=(int *)((int)a+1);//表示a的存储单元的地址增加一个字节
   //ptr2：按照上面的讲解，(int)a+1 的值是元素a[0]的第二个字节的地址。然后把这个地址强制转换成int*类型的值赋给ptr2，也就是说*ptr2 的值应该为元素a[0]的第二个字节开始的连续4 个byte 的内容

   printf("%x,%x",ptr1[-1],*ptr2);
//ptr1[-1]其实指向的是a数组的最后一个单元，*ptr1则表示a数组的地址后移一个字节之后的4个连续存储单元所存储的值
```
![解析](http://images.cnitblog.com/blog/256716/201310/22201259-c35f74944aa94ee4a893047ee9c23ded.jpg)




##### 两者总结 
` 优先级：() > [] > * == ++ `
- 数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间
- 指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
- 还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
比如要表示数组中i行j列一个元素：
` *(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j] `
> *(*(p+i)+j) 可以看出p本身移动步长是j，即是一行一行移动的

#### 大小端模式
大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放
> Big-Endian: 低地址存放高位，如下：
高地址
　　---------------
　　buf[3] (0x78) -- 低位
　　buf[2] (0x56)
　　buf[1] (0x34)
　　buf[0] (0x12) -- 高位
　　---------------
　　低地址
> Little-Endian: 低地址存放低位，如下：
高地址
　　---------------
　　buf[3] (0x12) -- 高位
　　buf[2] (0x34)
　　buf[1] (0x56)
　　buf[0] (0x78) -- 低位
　　--------------
低地址

##### 监测大小端
```C++
short int x；
char x0,x1;
x=0x1122;
x0=((char*)&x)[0]; //低地址单元
x1=((char*)&x)[1]; //高地址单元
```
若x0=0x11,则是大端; 若x0=0x22,则是小端 




#### 快速排序：递归与非递归
##### 递归法
```C++
template <typename Comparable>
int partition(vector<Comparable> & vec,int low,int high){
	Comparable pivot = vec[low] //任意index当基准
	while( low < high ){
		while( low < high && vec[high] >= pivot ){ // find first lower than pivot
			high--;
		vec[low] = vec[high];
		while( low < high )
			low++;
		vec[high] = vec[low];
	}
	//当low == high
	vec[low] = pivot;
	return low;  //返回最后基准位置
}
template <typename Comparable>
void QuickSort_Recursion(vector<Comparable> & vec, int low ,int high){
	if( low < high ){
		int mid = partition(vec,low,high);
		QuickSort_Recursion(vec,low,mid-1);
		QuickSort_Recursion(vec,mid+1,high);
	}
}

```
##### 非递归法
```C++
template <typename Comparable>
void QuickSort_Recursion(vector<Comparable> & vec, int low ,int high){
	if( low < high ){
		stack<int> s;
		if( low < high ){
			int mid = partitio(vec,low,high);
			if( low < mid - 1 ){
				s.push(low);
				s.push(mid-1);			
			}
			if( mid + 1 < high ){
				s.push(mid+1);
				s.push(high);			
			}
		}
		while(!s.empty()){
			// 取栈头的两个数p,q
			//
		QuickSort_Recursion(vec,mid+1,high);
			int q = s.top();
			s.pop();
			int p = s.top();
			s.pop()
			mid = partition(vec,p,q);
			if( p < mid-1 ){
				s.push(p);
				s.push(mid-1);				
			} 
			if( mid + 1 < q){
				s.push(mid+1);
				s.push(q);				
			}
		}
	}	
}
```
##### 时间复杂度
最差情况，已排好序，排序树退化成链表，每次一个子表为空，另一个为n-1，这样需要n-1趟，每趟n-i次比较，所以一共需要 ( n * ( n-1 )) / 2 次，退化到冒泡水平
一般情况，递归调用需要 O(NlogN) = cn + 2*T(n/2) 每次平分为两个表

##### 空间复杂度
最差情况，已排好序，排序树退化成链表，需要O(N)
一般情况，递归调用需要O(logN)

#### 归并排序
##### 空间复杂度降到O(1)：手摇算法
但是最差情况时间复杂度会变成O(N^2)

#### 堆排序
每次从堆里选最大/最小，与末尾元素交换（固定到末尾），再调整
O(NlogN)堆排序复杂性，
  
#### `*p++` 与 `*++p`
```C++
*p++ 先取指针p指向的值（数组第一个元素1），再将指针p自增1；
        cout << *p++; //  结果为 1
        cout <<(*p++);  // 1
(*p)++ 先去指针p指向的值（数组第一个元素1），再将该值自增1（数组第一个元素变为2
        cout << (*p)++; //  1
        cout <<((*p)++)  //2
*++p   先将指针p自增1（此时指向数组第二个元素），* 操作再取出该值
        cout << *++p; //  2
        cout <<(*++p)  //2
++*p  先取指针p指向的值（数组第一个元素1），再将该值自增1（数组第一个元素变为2）
      cout <<++*p; //   2    
        cout <<(++*p)  //2
```
注意，上面的每条cout输出，要单独输出才能得到后面的结果
### C++ vector必须先push_back
vector必须先push_back再用vec[i]去取，不然会运行报错，当然vec.get也是可以的

#### C++ 注意 gets与scanf交替，cin与getline交替时可能会吞字
```C++
	scanf("%d\n",&m); //注意'\n'
	cin>>k;
```
gets与scanf交替，cin与getline交替时可能会吞字


#### C++ String与char[]与`char*`
##### string转char[]
首先不可以printf("%s",string)，因为打印寻找的是地址，而string不是一个对象，运行会出错
###### string注意事项
- string可以直接比较 ==，而char[] 需要strcmp(const char *,const char *)
- string不能和NULL进行比较，判断string为空有：
```C++
    string test_string;
    string test_string_empty = "";	

    if (test_string == "") 
    if (test_string_empty.empty()) 
    if (test_string_empty.length() == 0)   

```

###### string.c_str()与string.data()
- data()是末尾不会跟'\0'的
- 不能直接 char[] a = string.c_str()，a只是获得了一个引用，在string被销毁后就不知道指到哪了
- 为内容赋值才可以，需要 char[] a = strcpy(string.c_str())

##### char[] 转 string
直接赋值

#### 字符串复制
sprintf 可以进行额外的格式化
strcpy 会复制直到出现 '' 为止，可能溢出
strncpy 会复制一个以 '' 结束的字符串，但是如果字符串长度超过指定数量则被截断，但结果可能不包含 '' 表示结束
memcpy 只负责复制指定数量的 bytes，不处理 '' 的情况
memmove 在 memcpy 的基础上对 overlap 的情况进行了处理

#### 内存访问，SSD硬盘访问和SATA硬盘随机访问的时间
内存访问速度通常在50ns到80ns范围内，SSD硬盘的访问速度一般是SATA硬盘的一千多倍

#### CP握手讲到 listen fd 的两个队列了吗?(就绪队列,未就绪队列), syn-flood问题, accept需要几次握手

#### C++面试
http://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html

#### 数据库中的左连接(left join)和右连接(right join)区别

#### 数据库索引的B Tree和Hash实现的区别

#### B树与B+树区别

####高精度浮点数

####p2p服务器



####udp怎么保证能收到数据

#### inline函数
inline int min(int first, int secend) {/****/};
- inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数
- inline函数必须在调用该函数的每个文本文件中定义
- 建议把inline函数的定义放到头文件中 
- 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用
- 定义在类声明之中的成员函数将自动地成为内联函数（构造等）
> 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的
执行效率，如果执行函数体内代码的时间，相比于函数调用的开销较大，那么优势就不复存在

 
- 每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间
##### 预处理宏
> 预处理器用复制宏代码的方式代替函数调用，省去了参数压栈、生成汇编语言的CALL调用、 
返回参数、执行return等过程，从而提高了速度。

对于C++ 而言，使用宏代码还有另一种缺点：无法操作类的私有数据成员

##### assert
assert是仅在Debug版本起作用的宏，它用于检查"不应该"发生的情况。 
为了不在程序的Debug版本和Release版本引起差别，assert不应该产生任何副作用。 
> assert不是函数，而是宏。
 
#### C++ 模板全特化和偏特化

#### 
- 常量间的相加并不会引起效率问题
- 变量字符串相加时，由于相加的变量中存放的是字符串的地址引用，因为在编译时无法确切地知道其他具体的值，也就没有办法对其进行优化处理，这时为了达到连接的效果，其内部采用了 StringBuilder 的机制进行处理（JDK 5 中新增的，我这里没有 JDK 1.4，估计在 JDK 1.4 下采用的是 StringBuffer），将他们都 append进去，最后用 toString 输出

#### C/C++的内存模型
1. 五大内存分区：堆、栈、全局/静态存储区、自由存储区和常量存储区。 (自由存储区是由malloc和free分配的)
2. 五大内存分区：堆、栈、全局/静态存储区、字符串常量区和代码区。

##### 堆：
手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请，堆的总大小为机器的虚拟内存的大小
- new操作符本质上是使用了malloc进行内存的申请，new和malloc的区别如下： 
（1）malloc是C语言中的函数，而new是C++中的操作符。 
（2）malloc申请之后返回的类型是void*，而new返回的指针带有类型。 
（3）malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数。
- 堆是向上的增长，也就是向着内存地址增加的方向
- 频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低
- 堆效率不高。堆是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会在堆内存中搜索可用的足够大小的空间，如果不够就需要调用系统功能去增加程序数据段的内存空间

>> 32位系统下，堆内存可以达到4G

##### 栈：
- 在X86体系中，栈开始于末端，并朝内存区开始的方向增长，也就是向着内存地址减小的方向
- 栈的效率比较高，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行
- 函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放
> 由编译器定义大小，VS为1M，64位Linux默认为10M，`ulimit -s` 修改

##### 全局变量/静态变量区
1. 存储区内的变量在程序编译阶段已经分配好内存空间并初始化
2. 全局变量和静态全局变量的存储方式是在一起的。**初始化的**全局变量和静态变量是在一起的，**未初始化的**全局变量和静态变量是在相邻的空间中。
3. 这块内存在程序的整个运行期间都存在，它主要存放**静态变量、全局变量和常量**
> 全局变量在整个源代码中都可以使用，而静态全局变量只能在当前文件中有效

####用户态 & 内核态
##### 用户态到内核态切换途径
1. 系统调用        
2. 中断 　　
3. 异常

##### 内核态和用户态的区别
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。
1. 每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。 

2. 内核态与用户态是操作系统的两种运行级别,跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。

3. 用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行**文件操作**，**网络数据**发送等操作，必须通过write，send等**系统调用**，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。
    至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。

####
在X86中调用中断int指令型**系统调用**后会把用户栈的%esp的值及相关寄存器压入**内核栈**中，系统调用通过iret指令返回，在返回之前会从内核栈弹出用户栈的%esp和寄存器的状态，然后进行恢复
- 进入内核态之前要保存进程的上下文，中断结束后恢复进程上下文，那靠的就是内核栈。

> 首先我们需要知道内核栈的栈指针位置，inux为每一个cpu提供一个tss段，并且在tr寄存器中保存该段。在从用户态切换到内核态时，可以通过获取TSS段中的esp0来获取当前进程的内核栈 栈顶指针，从而可以保存用户态的cs,esp,eip等上下文。


#### 同步与异步、阻塞与非阻塞
##### 阻塞调用和同步调用实际上是不同的
1. 对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已
2. 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回
> socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。
>> 在处理 IO 的时候，阻塞和非阻塞都是同步 IO。
只有使用了特殊的 API 才是异步 IO。
![同步与异步](https://pic2.zhimg.com/50/7d3eb389b7724878bd7e12ebc6dbcdb5_hd.jpg)

##### 阻塞IO和非阻塞IO的区别
> 阻塞和非阻塞是指当server端的进程访问的数据如果尚未就绪（进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪）

##### 同步IO和异步IO的区别
- 异步是*调用*在发出之后，这个调用就直接返回了，所以没有返回结果
> 同步和异步是指client端访问数据的机制



#### 
[校招面试知识点复习之计算机网络](http://blog.csdn.net/sinat_35512245/article/details/61926504)

#### 常见应用端口
POP3默认端口是110 应用层
SMTP默认端口是25 应用层
DNS默认端口是53 应用层
windows提供远程服务的Telnet的默认端口是23 应用层

#### TCP结束过程
![TCP结束时TIME_WAIT的出现时间](http://uploadfiles.nowcoder.com/images/20150908/750854_1441709073035_63AE357E551665FD79C9F49FF8BA7E13)
1. 

CLOSED：初始状态，表示没有任何连接。

- LISTEN：Server端的某个Socket正在监听来自远方的TCP端口的连接请求。

- SYN_SENT：发送连接请求后等待确认信息。当客户端Socket进行Connect连接时，会首先发送SYN包，随即进入SYN_SENT状态，然后等待Server端发送三次握手中的第2个包。

- SYN_RECEIVED：收到一个连接请求后回送确认信息和对等的连接请求，然后等待确认信息。通常是建立TCP连接的三次握手过程中的一个中间状态，表示Server端的Socket接收到来自Client的SYN包，并作出回应。

- ESTABLISHED：表示连接已经建立，可以进行数据传输。
FIN_WAIT_1：主动关闭连接的一方等待对方返回ACK包。若Socket在ESTABLISHED状态下主动关闭连接并向对方发送FIN包（表示己方不再有数据需要发送），则进入FIN_WAIT_1状态，等待对方返回ACK包，此后还能读取数据，但不能发送数据。在正常情况下，无论对方处于何种状态，都应该马上返回ACK包，所以FIN_WAIT_1状态一般很难见到。

- FIN_WAIT_2：主动关闭连接的一方收到对方返回的ACK包后，等待对方发送FIN包。处于FIN_WAIT_1状态下的Socket收到了对方返回的ACK包后，便进入FIN_WAIT_2状态。由于FIN_WAIT_2状态下的Socket需要等待对方发送的FIN包，所有常常可以看到。若在FIN_WAIT_1状态下收到对方发送的同时带有FIN和ACK的包时，则直接进入TIME_WAIT状态，无须经过FIN_WAIT_2状态。

- TIME_WAIT：主动关闭连接的一方收到对方发送的FIN包后返回ACK包（表示对方也不再有数据需要发送，此后不能再读取或发送数据），然后等待足够长的时间（2MSL）以确保对方接收到ACK包（考虑到丢失ACK包的可能和迷路重复数据包的影响），最后回到CLOSED状态，释放网络资源。
CLOSE_WAIT：表示被动关闭连接的一方在等待关闭连接。当收到对方发送的FIN包后（表示对方不再有数据需要发送），相应的返回ACK包，然后进入CLOSE_WAIT状态。在该状态下，若己方还有数据未发送，则可以继续向对方进行发送，但不能再读取数据，直到数据发送完毕。
- LAST_ACK：被动关闭连接的一方在CLOSE_WAIT状态下完成数据的发送后便可向对方发送FIN包（表示己方不再有数据需要发送），然后等待对方返回ACK包。收到ACK包后便回到CLOSED状态，释放网络资源。

- CLOSING：比较罕见的例外状态。正常情况下，发送FIN包后应该先收到（或同时收到）对方的ACK包，再收到对方的FIN包，而CLOSING状态表示发送FIN包后并没有收到对方的ACK包，却已收到了对方的FIN包。有两种情况可能导致这种状态：其一，如果双方几乎在同时关闭连接，那么就可能出现双方同时发送FIN包的情况；其二，如果ACK包丢失而对方的FIN包很快发出，也会出现FIN先于ACK到达


##### TCP结束时TIME_WAIT的出现时间

1. 防止上一次连接中的包，迷路后重新出现，影响新连接 （经过2MSL，上一次连接中所有的重复包都会消失）
2. 可靠的关闭TCP连接 
在主动关闭方发送的最后一个ack(fin) ，有可能丢失，这时被动方会重新发 fin, 如果这时主动方处于CLOSED 状态 ，就会响应rst 而不是ack。所以 主动方要处于TIME_WAIT 状态，而不能是CLOSED 。 TIME_WAIT 并不会占用很大资源的，除非受到攻击。 还有，如果一方send 或recv 超时，就会直接进入CLOSED 状态

MSL - maximum segment lifetime(最大分节生命期）
> 这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。
MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒。


TIME_WAIT状态维持时间


> TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟。Windows操作系统就是4分钟。

#### Peterson算法

#### python正则
re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配
##### 将匹配的数字乘于 2
```Python
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
 
s = 'A23G4HFD567'
print(re.sub('(?P<value>\d+)', double, s)) 
//答案为A46G8HFD1134，就像进位了一样
```
#### sleep() 是系统调用会陷入内核态

#### Spinlock自旋锁
#### sighub

#### 数据库
##### 索引为何使用B+树

##### 索引最左前缀原则
##### 哪些条件无法使用索引
如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
##### 主键、唯一索引、全文索引、覆盖索引 

#### TCP为什么需要3次握手与4次挥手
状态也很详尽地解释了：[TCP为什么需要3次握手与4次挥手](http://blog.csdn.net/xifeijian/article/details/12777187)



#### 
对于自定义类型，则必须自己重载 operator< 或者自己写仿函数
```C++
struct Node{
    int x, y;
    Node( int a= 0, int b= 0 ):
        x(a), y(b) {}
};
 
bool operator<( Node a, Node b ){
    if( a.x== b.x ) return a.y> b.y;
    return a.x> b.x; 
}

priority_queue<Node> q;
```
不然
```C++
priority_queue<int, vector<int>, greater<int> > q;  小顶堆
priority_queue<int, vector<int>, less<int> > q;  大顶堆
```

>> ps:如果重载operator > 可直接使用
`priority_queue<Node,vector<Node>,greater<Node>>`


##### priority_queue实现
priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数:
priority_queue<Type, Container, Functional>
其中Type 为数据类型， Container 为保存数据的容器，Functional 为元素比较方式。
Container 必须是用数组实现的容器，比如 vector, deque 但不能用 list.
STL里面默认用的是 vector. 比较方式默认用 operator< , 所以如果你把后面俩个参数缺省的话，
优先队列就是大顶堆，队头元素最大
```C++ 
#include <iostream>
#include <algorithm>
#include <vector> 
using namespace std; 
class priority_queue
{
    private:
        vector<int> data;
         
    public:
        void push( int t ){ 
            data.push_back(t); 
            push_heap( data.begin(), data.end()); 
        }
         
        void pop(){
            pop_heap( data.begin(), data.end() );
            data.pop_back();
        }
         
        int top() { return data.front(); }
        int size() { return data.size(); }
        bool empty() { return data.empty(); }
};
```
STL里面的 priority_queue 写法与此相似，[原文出处](http://www.cnblogs.com/flyoung2008/articles/2136485.html)